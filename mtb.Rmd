---
title: "Untitled"
output: html_document
date: "2022-11-02"
editor_options: 
  chunk_output_type: console
bibliography: references.bib
---

```{r setup, include = FALSE}
pacman::p_load(tidyverse, tximport, biomaRt, DESeq2, WGCNA, cowplot, patchwork)
```

```{r cliff}
# prep metadata -----------------------------------------------------------

metadata = data.frame(names = list.dirs("./data/kallisto",full.names = F),
                      files = list.dirs("./data/kallisto",full.names = T))[-1,]
metadata$files = paste0(metadata$files,"/abundance.h5")
metadata$time = gsub(".*_(T.*?)_.*","\\1",metadata$names)
metadata$background = gsub(".*?_(.*?)_.*","\\1",metadata$names)
metadata$treatment = gsub(".*_T.*?_(.*?)_.*","\\1",metadata$names)
metadata$treatment[metadata$time=="T0"] = "uninf"
metadata$group = paste0(metadata$background, "___",metadata$treatment, "___", metadata$time)
rownames(metadata) = metadata$names

# import data -------------------------------------------------------------
files = metadata$files
names(files) = metadata$names
tx = tximport::tximport(files, type = "kallisto", txOut = TRUE)

# Build reference mapping -------------------------------------------------
mart = useEnsembl(biomart = "ensembl",
               dataset = "mmusculus_gene_ensembl",
               mirror = "useast")

t2g = getBM(attributes = c("refseq_mrna", "external_gene_name"),mart = mart)
t2g = dplyr::rename(t2g, 
                    target_id = refseq_mrna,
                    gene_id = external_gene_name)
t2g = t2g[t2g$target_id!="",]
t2g = t2g[match(gsub("\\..*","",rownames(tx$abundance)),t2g$target_id),]
t2g$target_id = rownames(tx$abundance)
t2g = t2g[!is.na(t2g$gene_id),]

gene = summarizeToGene(tx,tx2gene = t2g)
gene_lengthScaledTPM = summarizeToGene(tx,tx2gene = t2g, countsFromAbundance = "lengthScaledTPM")
```

```{r metadata}
metadata <- tibble::tribble(
                 ~name, ~background, ~time, ~treatment, ~replicate,
            "01_wt_T0_1",      "wt",  "T0",    "uninf",         "1",
            "02_wt_T0_2",      "wt",  "T0",    "uninf",         "2",
            "03_wt_T0_3",      "wt",  "T0",    "uninf",         "3",
         "04_NLRP3_T0_1",   "NLRP3",  "T0",    "uninf",         "1",
         "05_NLRP3_T0_2",   "NLRP3",  "T0",    "uninf",         "2",
         "06_NLRP3_T0_3",   "NLRP3",  "T0",    "uninf",         "3",
          "07_MAVS_T0_1",    "MAVS",  "T0",    "uninf",         "1",
          "08_MAVS_T0_2",    "MAVS",  "T0",    "uninf",         "2",
          "09_MAVS_T0_3",    "MAVS",  "T0",    "uninf",         "3",
       "10_wt_T24_inf_1",      "wt", "T24",      "inf",         "1",
       "11_wt_T24_inf_2",      "wt", "T24",      "inf",         "2",
       "12_wt_T24_inf_3",      "wt", "T24",      "inf",         "3",
     "13_wt_T24_uninf_1",      "wt", "T24",    "uninf",         "1",
     "14_wt_T24_uninf_2",      "wt", "T24",    "uninf",         "2",
     "15_wt_T24_uninf_3",      "wt", "T24",    "uninf",         "3",
    "16_NLRP3_T24_inf_1",   "NLRP3", "T24",      "inf",         "1",
    "17_NLRP3_T24_inf_2",   "NLRP3", "T24",      "inf",         "2",
    "18_NLRP3_T24_inf_3",   "NLRP3", "T24",      "inf",         "3",
  "19_NLRP3_T24_uninf_1",   "NLRP3", "T24",    "uninf",         "1",
  "20_NLRP3_T24_uninf_2",   "NLRP3", "T24",    "uninf",         "2",
  "21_NLRP3_T24_uninf_3",   "NLRP3", "T24",    "uninf",         "3",
     "22_MAVS_T24_inf_1",    "MAVS", "T24",      "inf",         "1",
     "23_MAVS_T24_inf_2",    "MAVS", "T24",      "inf",         "2",
     "24_MAVS_T24_inf_3",    "MAVS", "T24",      "inf",         "3",
   "25_MAVS_T24_uninf_1",    "MAVS", "T24",    "uninf",         "1",
   "26_MAVS_T24_uninf_2",    "MAVS", "T24",    "uninf",         "2",
   "27_MAVS_T24_uninf_3",    "MAVS", "T24",    "uninf",         "3"
  ) 

# creating treatment2 from a linear combination of time and treatment
metadata <- metadata |>
mutate(time_treat = case_when(time == "T24" & treatment == "uninf" ~ "bystander",
                              time == "T24" & treatment ==   "inf" ~  "infected",
                              time ==  "T0" & treatment == "uninf" ~ "baseline"),
       back_treat =  paste0(background, "_", treatment)
       )

metadata <- metadata |>
  column_to_rownames("name") |>
  mutate(background = background |> as.factor() |> relevel(ref = "wt"),
         time = time |> as.factor() |> relevel(ref = "T0"),
         treatment = treatment |> as.factor() |> relevel(ref = "uninf"),
         time_treat = time_treat |> as.factor(),
         time_treat = fct_relevel(time_treat, c("baseline", "bystander", "infected")),
         back_treat = back_treat |> as.factor() |> relevel(ref = "wt_uninf")
         ) |> 
  dplyr::select(background, time, treatment, time_treat, back_treat, replicate)
```

## what is the effect of including an extra term in the model

-   an extra additive term in the model changes the underlying test from an unpaired t-test to a paired t-test.
-   it does not change the slope estimate (beta), it only changes its SE, and hence the t- & p-value
-   Quote from [@Sainani2010] explaining why the SE changes, "... the paired t-test only has to account for one source of variability (variability within pairs) rather than 2 sources (variability from two groups of twins)."
-   The unpaired t-test uses the third formula but the paired t-test uses the fourth formula of the [five formulas given here](https://miroslavtushev.medium.com/a-simple-trick-to-understand-the-t-test-2c2a9e7f1dc5)
-   Restated in terms of the metadata here, the SE changes because an unpooled rather than a pooled variance is calculated. That unpooled variance is calculated over the $(un)infected-baseline$ pairwise differences (where the differences are paired within the respective backgrounds).

## what does the intercept include

-   the intercept includes first levels of both the first and the second terms.
-   removing the intercept still presents the estimates for all levels of the second term relative to its first level.

## what is the meaning of interactions

-   an interaction represents the linear combination of two preexisting terms. For example, here the results of time:treatment interaction and treatment2 would be identical (but the intercepts of the two models would be different).


```{r testing, eval=FALSE, include=FALSE}
metadata$abundance <- gene$abundance[1,]

without_inter_m <- lm(abundance ~ background + time_treat, 
                      data = metadata |> filter(background != "NLRP3")
                      )

with_inter_m <- lm(abundance ~ background * time_treat, 
                      data = metadata |> filter(background != "NLRP3")
                      )

emmeans(without_inter_m, pairwise ~ time_treat | background, infer = TRUE)
emmeans(with_inter_m, pairwise ~ time_treat | background, infer = TRUE)

without_inter <- emmip(without_inter_m, background ~ time_treat, CIs = TRUE) + 
  labs(title = "Without Interaction", y = "Gene '1' abundance") +
  ggrepel::geom_text_repel(data = function(x) subset(x,time_treat == "infected"),
                           aes(label = background)) +
  theme_half_open() + 
  theme(axis.title.x = element_blank(),
        legend.position = "none")

with_inter <- emmip(with_inter_m, background ~ time_treat, CIs = TRUE) + 
  labs(title = "With Interaction", y = "Gene '1' abundance") +
  ggrepel::geom_text_repel(data = function(x) subset(x,time_treat == "infected"),
                           aes(label = background)) +
  theme_half_open() + 
  theme(axis.title.x = element_blank(),
        legend.position = "none")

without_inter + with_inter
```

There is no correlation between the replicates with the same number across different genotypes. In other words: the replicates are nested within genotypes, not across them 
https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html#model-specification

Rank genes on the basis of their enrichment scores.

```{r deg_baseline_bystander}
deg <- DESeqDataSetFromMatrix(
  countData = gene$abundance |> as.data.frame() |> dplyr::select(-contains(c("NLRP3", "T24_inf"))) |> round(),
  colData = metadata |> filter(background != "NLRP3", time_treat != "infected"),
  design = ~ background * time_treat
  )

deg <- DESeqDataSetFromMatrix(
  countData = gene$abundance |> as.data.frame() |> dplyr::select(-contains(c("NLRP3", "T24_inf"))) |> round(),
  colData = metadata |> filter(background != "NLRP3", time_treat != "bystander"),
  design = ~ background * time_treat
  )

deg <- DESeqDataSetFromMatrix(
  countData = gene$abundance |> as.data.frame() |> dplyr::select(-contains(c("NLRP3", "T24_inf"))) |> round(),
  colData = metadata |> filter(background != "NLRP3", time_treat != "uninfected"),
  design = ~ background * time_treat
  )

model.matrix(object = ~ background * time_treat, 
             data = metadata |> filter(background != "NLRP3") |> droplevels())

deg <- DESeq(deg)
# Generate results object

resultsNames(deg)

# by default results outputs the last named contrast above

Intercept <- results(name = "Intercept", object = deg) |> 
  as.data.frame() |> rownames_to_column()

t0_background <- results(name = "background_MAVS_vs_wt", object = deg) |> 
  as.data.frame() |> rownames_to_column()

t24_bystander <- results(name = "time_treat_uninf_vs_baseline", object = deg) |> 
  as.data.frame() |> rownames_to_column()

t24_infected <- results(name = "time_treat_inf_vs_baseline", object = deg) |> 
  as.data.frame() |> rownames_to_column()

interaction_bystander <- results(name = "backgroundMAVS.time_treatuninf", object = deg) |>
  as.data.frame() |> rownames_to_column()

interaction_infected <- results(name = "backgroundMAVS.time_treatinf", object = deg) |> 
  as.data.frame() |> rownames_to_column()

lfcs <- map_dfc(.x = resultsNames(deg), ~DESeq2::results(name = .x, object = deg) |> 
  as.data.frame() |> dplyr::select(log2FoldChange))

names(lfcs) <- resultsNames(deg)

mtb |> View()
```

# GSEA
Quote from fgsea reference manual describing the columns of the output.
https://bioconductor.org/packages/release/bioc/manuals/fgsea/man/fgsea.pdf

Each row corresponds to a tested pathway. The columns are the following:
• pathway – name of the pathway as in ‘names(pathway)‘;
• pval – an enrichment p-value;
• padj – a BH-adjusted p-value;
• ES – enrichment score, same as in Broad GSEA implementation;
• NES – enrichment score normalized to mean enrichment of random samples of the same size;
• nMoreExtreme‘ – a number of times a random gene set had a more extreme enrichment score value;
• size – size of the pathway after removing genes not present in ‘names(stats)‘.
• leadingEdge – vector with indexes of leading edge genes that drive the enrichment, see http://software.broadinstitute.org/gsea/doc/GSEAUserGuideTEXT.htm#_Running_a_Leading

```{r gsea}
library(fgsea)
library(dorothea)
library(progeny)

hallmarks <- fgsea::gmtPathways("./data/pathway datasets/hallmark.genesets.v6.1.symbols.gmt") #50 gene sets
kegg <- fgsea::gmtPathways("./data/pathway datasets/kegg.genesets.v6.1.symbols.gmt") #186
go <- fgsea::gmtPathways("./data/pathway datasets/GOTerms.BP.v6.1.symbols.gmt") #4436
reactome <- fgsea::gmtPathways("./data/pathway datasets/reactome.genesets.v6.1.symbols.gmt") #674

gene_sets <- c(hallmarks, kegg, go, reactome)


mtb <- read_csv("~/mtb/results/DESeq/logFCs.csv")

gene_names<- mtb |> drop_na() |> pluck("...1")

for(i in 2:73){ 
  names(mtb[[i]]) <- gene_names

}

fold_changes <- vector("list", length = 72)

for(i in 2:73){
  fold_changes[[i]] <- mtb[[i]] |> sort()
}

pathways <- vector("list", length = 72)

for(i in 2:28){
  pathways[[i]] <- fgsea(pathways = gene_sets,
                         stats = fold_changes[[i]],
                         minSize=5,
                         maxSize=5000,
                         nproc = 2)
}

names(pathways) <-  mtb |> dplyr::select(-1) |> names() |> str_replace_all("___", "_") |> str_replace_all(" -- vs -- ", "—")

singletons <- names(pathways) |> str_split_fixed("—", n =2) |> as.data.frame() |> pluck(1) |> unique()

keep <- map_dfr(.x = 1:8, ~expand.grid(singletons[.x], singletons[(.x+1):9])) |> transmute(Var3 = paste0(Var1, "—", Var2)) |> pluck(1)

pathways2 <- pathways[keep]

map_dfr(.x = pathways2 |> discard(is.null), ~dplyr::filter(.x, pval <= 0.05), .id = "comparison") |> 
write.xlsx(file = "pathways1.xlsx")

write.xlsx(pathways2, file = "pathways2.xlsx")
```

Use the Bioconductor package ReportingTools for displaying the results [@Huntley2013]. Excerpt from @Love2015 about ReportingTools:

> ReportingTools will automatically generate dynamic HTML documents, including links to external databases using gene identifiers and boxplots summarizing the normalized counts across groups.

```{r}
# BiocManager::install("ReportingTools")
library("ReportingTools")
htmlRep <- HTMLReport(shortName="report", title="My report",
                      reportDirectory="./report")
publish(df |> slice_min(pval, n = 100), htmlRep)
url <- finish(htmlRep)
browseURL(url)
```
